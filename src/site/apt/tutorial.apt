			------
            Tutorial 1
            ------
            Sven Ewald
            ------
             2012
			------
			
%{toc|toDepth=2}

Tutorial Examples

 This tutorial guides you through seven examples, each demonstrating a couple of XMLBeam features. Each example works on real life XML Data. Have fun! 
			
*E01: Printing some weather data.

**Motivation

 This example should give you a first impression of the basic XMLBeam features:
 
  * Accessing XML attributes with automatic type conversion.
  
  * Sub projections grouping data

** XML Content

 Using the MSN weather service will get you some XML content similar to this:
   
---------
<weatherdata>
      <weather
        ... 
      	degreetype="F"
      	lat="50.5520210266113" lon="6.24060010910034" 
      	searchlocation="Monschau, Stadt Aachen, NW, Germany" 
		... >
        <current ... skytext="Clear" temperature="46"/>
      </weather>
</weatherdata>
---------
 We see that the XML structure consists of three elements and number of attributes holding the data. 
 If you execute the tutorial example code you will see that there are even more attributes that are shortened out here for readability.
 If you would use a data binding XML library to access this data you would get three Java classes, two of them actually holding interesting parts.
 
** Projection 
 
 Using data projection we define a single interface, hiding the XML tree structure:

%{snippet|id=WeatherDataInterface|url=file:src/test/java/org/xmlbeam/tutorial/e01_weather/WeatherData.java}

 Hey, what does the inner interface "Location" do there? This declares that we like to group the two attributes holding the coordinates together in one object.
 It is not only possible to hide elements of the xml structure, but to enrich the structure with pretended objects.
 
** Example Code
 
 Here the code to run the example:
 
%{snippet|id=WeatherDataCode|url=file:src/test/java/org/xmlbeam/tutorial/e01_weather/TestWeatherData.java}

*E02: Reading a Jenkins Job Configuration

**Motivation

 In the last example we demonstrated a sub projection pretending a non existing element.
 This time we like to define some model classes for a Jenkins job configuration and project existing elements to them.
 But there is one little hurdle: We can not know the exact XML structure, because Jenkins plugins contribute new elements with different names.
 Our model would have to include one class for each contributed element, but we like to keep the number of model classes low.
 
 The solution to this shows: 
  
 * Usage of XPath wildcards
   Mapping of varying elements to one Java object. 
 
 * Automatic conversion of sequences to lists and arrays
   Static typed API using Java generics.
   
 * Declarative document origins.
   Just add a source URL via annotation, let the framework get the document.
   
 * Inheritance in projection interface.
   Java interface inheritance is still supported in projection interfaces.     

 []
  
 Instead of defining one model class for each element, we project all elements doing the same stuff to the same model object. 
 This is done by using XPath wildcards that will simply select all elements in a defined subtree. 
 Of course we define a getter method to give us the element name, so we can use our model to find out what which elements are really in there. 
   
 
**XML Content

**Model Interfaces   

%{snippet|id=JenkinsModelElementInterface|url=file:src/test/java/org/xmlbeam/tutorial/e02_jenkins/model/ModelElement.java}
%{snippet|id=JenkinsPublisherInterface|url=file:src/test/java/org/xmlbeam/tutorial/e02_jenkins/model/Publisher.java}
%{snippet|id=JenkinsBuilderInterface|url=file:src/test/java/org/xmlbeam/tutorial/e02_jenkins/model/Builder.java}

** Projection API 

%{snippet|id=JenkinsJobConfigInterface|url=file:src/test/java/org/xmlbeam/tutorial/e02_jenkins/JenkinsJobConfig.java}

*E03: Eclipse Configuration File

 * Dynamic projections

*E04: Maven POM

 * Modify an element value

 * Reuse a projection for similar elements 

*E05: RSS

 * Modify multiple elements
 
 * Accessing namespaced elements

*E06: XHTML

 * Create a new document from scratch
 
 * Usage of configuration injection to modify the output transformer.
 
*E07: SVG

 * Add behavior to projections by adding a Mixin.