			------
            Tutorial 1
            ------
            Sven Ewald
            ------
             2012
			------

Tutorial Examples

 This tutorial guides you through nine examples, each demonstrating a couple of XMLBeam features.
 You will find these examples ready to run in "src/test/java/tutorial".
 Each example works on real life XML Data. <<Have fun!>> 

%{toc|section=1|fromDepth=2|toDepth=2}
	
*E01: Printing some weather data.			
			
%{include|source-content-type=apt|source=src/site/apt/t01_desc.txt}

 {{{./t01.html}Tutorial 1}}!

*E02: Reading a Jenkins Job Configuration

 In the last example we demonstrated a sub projection pretending a non existing element.
 This time we like to define some model classes for a Jenkins job configuration and project existing elements to them.
 But there is one little hurdle: We can not know the exact XML structure, because Jenkins plugins contribute new elements with different names.
 Our model would have to include one class for each contributed element, but we like to keep the number of model classes low.
 
 The solution to this shows: 
  
 * Usage of XPath wildcards.
   Mapping of varying elements to one Java object. 
 
 * Automatic conversion of sequences to lists and arrays utilizing Java generics to provide a static typed API.
   
 * Declarative document origins.
   Just add a source URL via annotation, let the framework get the document.
   
 * Inheritance in projection interface.
   Java interface inheritance is still supported in projection interfaces.     

 []
  
 Instead of defining one model class for each element, we project all elements doing the same stuff to the same model object. 
 This is done by using XPath wildcards that will simply select all elements in a defined subtree. 
 Of course we define a getter method to give us the element name, so we can use our model to find out what which elements are really in there. 
   
 
**XML Content

**Model Interfaces   

 Our example should read all builder and all publisher elements in the configuration file.
 We like to know the element names of both, so we define a super interface "ModelElement" and let our model objects extend it.

%{include|highlight-theme=eclipse|show-gutter=false|snippet=#JenkinsModelElementInterface|source=src/test/java/org/xmlbeam/tutorial/e02_jenkins/model/ModelElement.java}
%{include|highlight-theme=eclipse|show-gutter=false|snippet=#JenkinsPublisherInterface|source=src/test/java/org/xmlbeam/tutorial/e02_jenkins/model/Publisher.java}
%{include|highlight-theme=eclipse|show-gutter=false|snippet=#JenkinsBuilderInterface|source=src/test/java/org/xmlbeam/tutorial/e02_jenkins/model/Builder.java}

** Projection API 

 Now that we have our model objects defined, we need to define how to retrieve them. 

%{include|highlight-theme=eclipse|show-gutter=false|snippet=#JenkinsJobConfigInterface|source=src/test/java/org/xmlbeam/tutorial/e02_jenkins/JenkinsJobConfig.java}

*E03: Eclipse Configuration File

 Eclipse code formatter settings are stored in profiles. In this example we like to access the data of a certain profile.
 Features shown in this example:
 
 * Dynamic projections
   Getter methods may be declared with parameters. 
   There parameters will fill placeholders in the XPath declaration to build up the final XPath expression.
   Syntax of this is the MessageFormat format syntax.  
 
**XML Content

-----------
<profiles version="8">
    <profile name="Some Profile" version="8">
        <setting
            id="org.eclipse.jdt.core.formatter.align_type_members_on_columns"
            value="false" />
        <setting
            id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression"
            value="16" />
... 
    </profile>
    <profile name="Another Profile" version="8">
        <setting
            id="org.eclipse.jdt.core.formatter.align_type_members_on_columns"
            value="true" />
        <setting
            id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression"
            value="16" />
 ...
    </profile>
</profiles>
----------- 
 
** Projection API 

%{include|highlight-theme=eclipse|show-gutter=false|snippet=#EclipseCodeFormatterConfig|source=src/test/java/org/xmlbeam/tutorial/e03_eclipse/EclipseFormatterConfigFile.java}

** Example Code

%{include|highlight-theme=eclipse|show-gutter=false|snippet=#TestEclipseCodeFormatterConfig|source=src/test/java/org/xmlbeam/tutorial/e03_eclipse/TestEclipseCodeFormatterConfig.java}

*E04: Maven POM

 A Maven project has a group id, artefact id and a version.
 So does a Maven dependency.
 Now we reuse the same sub projection for unrelated, but similar parts of the document.
 This is possible because the structure of our projection does not need to follow the structure of the document.
 
 Second we define a simple setter in the projection interface to show how element values can be modified.  

** Projection API

%{include|highlight-theme=eclipse|show-gutter=false|snippet=#MavenPOM|source=src/test/java/org/xmlbeam/tutorial/e04_maven/MavenPOM.java}

** Example Code

%{include|highlight-theme=eclipse|show-gutter=false|snippet=#TestMavenPOM|source=src/test/java/org/xmlbeam/tutorial/e04_maven/TestMavenPOM.java}

*E05: RSS

 Instead of just setting an elements value like in the last example, we now change a sequence of elements.
 Notice that there are name spaces in the source XML document and that we work with them intuitively.

** Projection API

%{include|highlight-theme=eclipse|show-gutter=false|snippet=#SlashdotRSSFeed|source=src/test/java/org/xmlbeam/tutorial/e05_rss/SlashdotRSSFeed.java}

** Example Code

 And here some unit tests to print out some data about our RSS feed.
 
%{include|highlight-theme=eclipse|show-gutter=false|snippet=#=TestFilterRSSFeed|source=src/test/java/org/xmlbeam/tutorial/e05_rss/TestFilterRSSFeed.java}

*E06: XHTML

 * Create a new document from scratch
 
 * Usage of configuration injection to modify the output transformer.

** Projection API

%{include|highlight-theme=eclipse|show-gutter=false|snippet=#XHTML|source=src/test/java/org/xmlbeam/tutorial/e06_xhtml/XHTML.java}

** Example Code

%{include|highlight-theme=eclipse|show-gutter=false|snippet=#TestCreationOfXHTMLDocument|source=src/test/java/org/xmlbeam/tutorial/e06_xhtml/TestCreationOfXHTMLDocument.java}
 
*E07: SVG

 * Add behavior to projections by adding a Mixin.
 
** Projection API
 
%{include|highlight-theme=eclipse|show-gutter=false|snippet=#SVGDocument|source=src/test/java/org/xmlbeam/tutorial/e07_svg/SVGDocument.java}
 
** Example Code
 
%{include|highlight-theme=eclipse|show-gutter=false|snippet=#TestSVGElementSorting|source=src/test/java/org/xmlbeam/tutorial/e07_svg/TestSVGElementSorting.java}
 
*E08: API Mimicry

** Projection API

 In this example we do something special: 
 
 * Projection of a complete unknown XML structure.
 
 * Building our Java API analog to DOM4J.
 
 The result is a generic Java API you can use to analyze every XML document.  

%{include|highlight-theme=eclipse|show-gutter=false|snippet=#Document|source=src/test/java/org/xmlbeam/tutorial/e08_api_mimicry/Document.java}

%{include|highlight-theme=eclipse|show-gutter=false|snippet=#Element|source=src/test/java/org/xmlbeam/tutorial/e08_api_mimicry/Element.java}

%{include|highlight-theme=eclipse|show-gutter=false|snippet=#Attribute|source=src/test/java/org/xmlbeam/tutorial/e08_api_mimicry/Attribute.java}
 
** Example Code

%{include|highlight-theme=eclipse|show-gutter=false|snippet=#TestDom4jMimicry|source=src/test/java/org/xmlbeam/tutorial/e08_api_mimicry/TestDom4jMimicry.java}

